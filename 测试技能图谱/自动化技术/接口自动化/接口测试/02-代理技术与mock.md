# 02-代理技术与mock

## 一、Get与Post的区别

- 测试http请求demo例子

```
from flask import Flask, session, request, Request, make_response

app = Flask(__name__)
request: Request
app.secret_key = "key"


@app.route("/request", methods=['POST', 'GET'])
def hello():
    query = request.args
    post = request.form
    return f"query: {query}\n" \
           f"post: {post}"


@app.route("/session")
def session_handle():
    for k, v in request.args.items():
        session[k] = v
    resp = make_response({k: v for k, v in session.items()})
    for k, v in request.args.items():
        resp.set_cookie(f"cookie_{k}", v)
    return resp
```


运行命令：

```
export FLASK_APP=flaskdemo.py
flask run
```
运行成功之后，本地会开启一个服务，端口5000:

```
* Debug mode: off
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

在浏览器输入：http://127.0.0.1:5000/request， 返回以下内容，代表环境准备OK：
query: ImmutableMultiDict([]) post: ImmutableMultiDict([])

- 发送get和post请求
```
curl -s 'http://127.0.0.1:5000/request?a=1&b=2' -v &>/tmp/get
curl -s 'http://127.0.0.1:5000/request?a=1&b=2' -d "c=3&d=4" -v &>/tmp/ post
```

-  diff 对比：
  - 使用pychare copy path，将生产的get和post文件进行拷贝
  -  cp get post /Users/user/PycharmProjects/SDET11-LY
  - 使用pycharm中compare files 功能打开文件进行对比


![get&post请求对比](_v_images/20200704141650180_128007272.png =1193x)


- get与post区别的总结
  - http的method字段不同
  - post可以附加body，可以支持form、json、xml、binary、等各种数据格式
  - 行业通用规范
    - 无状态变化的建议使用get请求，例如查询
    - 数据的写入与状态修改建议使用post
  - get是从服务器获取资源，不会涉及服务器资源变更，post请求可能会让服务器资源发生变化。HTTP本身没有对URL的长度和传输的数据大小进行限制，对于GET，特定的浏览器和服务器对URL的长度有限制。对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制
  - GET产生一个TCP数据包；POST产生两个TCP数据包，对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）
  - GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
  - GET请求一般都会设置缓存，且幂等

- HTTP请求格式
<method> <request-URL> <version>
<headers>

<entity-body>

首行是一个请求行，包括请求方法，请求URL，报文HTTP信息
紧接着是请求header（首部），可以包含多个信息，
首部下面是一个空行
最后是报文的主体部分，存放数据的实体

- HTTP响应格式
<version> <status> <reason-phrase>
<headers>

<entity-body>


状态行：版本、状态码、
响应header(响应首部信息)
空行
返回实体报文数据


## 二、session cookie token区别


普通get 与带session请求的diff对比

```
curl -s 'http://127.0.0.1:5000/session?c=1&b=2' -v &>/tmp/session
cp session /Users/user/PycharmProjects/SDET11-LY
```

![get请求有无sessin对比](_v_images/20200709103523191_1285501422.png =1193x)

有session服务器会返回响应header内容，包括设置cookie内容。可以看见session是一个很长的唯一标识，并不会因为前端参数长短而sessionn值长度发生变化，session值是固定长度的。浏览器设置cookie之后，下次发生请求会将cookie中的内容传递给服务器。

要了解cookie、session、token就需要知道HTTP协议特征：

- http是一个无状态协议
什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是，比如用户完成一次购物要先登录，下单、支付等，如果不能记住用户的操作，后面每一步都需要登录拿到用户的信息，相当繁琐。如果想把同一个用户的所有操作关联起来就必须使用一些手段和工具

为了解决无状态的问题，session和cookie就随之诞生了。

- cookie
cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。
cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

- session
session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。
session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。
服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

- token
随着session 存储在服务器，就会导致服务器开销越来越大，为了解决服务器不存储的开销，诞生了token，我们不将用户信息存在服务器或Session中。token 是多用户下处理认证的最佳方式

token 特点：
  - 无状态、可扩展
  - 支持移动设备
  - 跨程序调用
  - 安全



基于服务器验证存在的问题
 1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。
 2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。
 3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。
 4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。

基于token验证原理
基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。这种概念解决了在服务端存储信息时的许多问题

  1.用户通过用户名和密码发送请求。
  2.程序验证。
  3.程序返回一个签名的token 给客户端。
  4.客户端储存token,并且每次用于每次发送请求。
  5.服务端验证token并返回数据。

每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求

总结：
    session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie
    cookie存储与客户端，装有sessionId(服务器加密后返回用户信息的唯一标识)，接受服务器相关set-cookie指令，将数据保存至本地。
    token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。


## 三、代理工具

- 常用代理工具：
  - 代理工具:charles、burpsuite、fiddler、mitmproxy 
  - 高性能代理服务器:squid、dante
  - 反向代理:nginx 
  - 流量转发与复制:em-proxy、gor、iptable、nginx 
  - socks5代理:ssh -d参数


- 代理的工作机制
![](_v_images/20200709143006478_1736910734.png =1053x)


- 优秀代理工具具备特性：
  - 代理功能:http/https、socks5
  - 请求模拟工具:拼装请求、重放请求，重复请求
  - 网络环境模拟:限速、超时、返回异常
  - mock:请求修改、响应修改
  - fake:用测试环境替代真实环境
 

- 推荐工具
  - charles:开发/测试工程师必备 
  - mitmproxy:测试开发工程师必备 
  - zap:测试工程师安全测试工具 
  - burpsuite:黑客必备渗透测试工具 
  - fiddler:跨平台支持不好，不推荐 
  - postman:代理功能太弱，不推荐


### charles工具

下载地址：https://www.charlesproxy.com/download/

安装成功界面如下(注意charles是收费工具，30分钟需求重启)
![charles](_v_images/20200709171150824_327455554.png =1037x)


- charles工具代理配置
  - 菜单栏点击proxy，把mac-proxy选项去掉，mac-proxy如果勾选，电脑上所有请求都会走代理(特别资源浪费)。

  - 设置SSL proxy
![](_v_images/20200709172128040_1692392464.png =1199x)


点击Add，添加需要监听的主机和端口地址(如果不输入，则是任意主机任意端口)
![](_v_images/20200709172524544_619237933.png =440x)


 - 设置proxy-setting(设置监听端口)
![](_v_images/20200709173852490_826186569.png =592x)

设置代理监听的端口号，然后勾选Enable transparent HTTP proxyinng，代理工具就设置完毕


浏览器代理插件工具(SwitchyOmega)


![建立代理模式](_v_images/20200709192910607_1940115482.png =1342x)


- 获取证书
![证书安装](_v_images/20200709182925163_88403681.png =1140x)

点击添加
![](_v_images/20200709183005134_1889466490.png =535x)

查看证书状态，未被信任
![](_v_images/20200709183150376_1422609241.png =877x)

双击证书，全部信任
![信任证书](_v_images/20200709183337367_1858071436.png =513x)

完成证书信任
![](_v_images/20200709183415389_2046913825.png =530x)



- Android证书安装
  - 配置代理
  - 访问 chls.pro/ssl
  - 安装证书
 

- IOS 安装证书
  - 配置代理
  - 访问 chls.pro/ssl
  - 安装证书
  - 信任证书


信任证书需要操作2个地方：

- 通用-描述文件与设备管理-信任charles证书
-  关于本机--证书信任设置-针对跟证书启用完全信任

charles激活：https://zhuanlan.zhihu.com/p/72138226


- Android证书信任问题
![](_v_images/20200710101013244_525259165.png =1094x)


### mock功能

- map remote

Map Remote 是将指定的网络请求重定向到另一个网址

例子，将访问百度请求，定向至腾讯首页
1.打开tools菜单，选择map remote选项
![](_v_images/20200713205201119_875556120.png =1033x)

2.勾选enable功能
![](_v_images/20200713205357657_913759596.png =864x)

3.输入重定向的请求及访问域名
![](_v_images/20200713205500731_901970275.png =440x)

4.点击OK，
![](_v_images/20200713205526234_327347752.png =540x)

5.浏览器访问baidu.com,跳转至腾讯首页
![](_v_images/20200713205655805_2028047897.png =1346x)




- map local功能

可以将服务器返回的内容存在本地文件，通过map-local可以指定本地文件内容进行返回。(从而达到可以本地随意修改文件内容达到需要返回内容的效果)

1.打开tools选择map local菜单
![](_v_images/20200713210641099_540559695.png =976x)


2.勾选enable，点击add
![](_v_images/20200713210724699_1330967055.png =801x)


3.输入网址选择本地文件
![](_v_images/20200713211215721_1373626233.png =472x)

4.点击OK，浏览器输入baidu.com
![](_v_images/20200713211633988_911068885.png =1369x)



- rewrite 功能

可以修改请求参数，也可以修改返回值

修改雪球app股票，将特斯拉修改为满帮集团，12.19修改为80.99
![](_v_images/20200713215338761_776347085.png =493x)



操作步骤  

1.打开tools菜单选择rewrite

![](_v_images/20200713220018565_2102302070.png =919x)

2.添加规则
![](_v_images/20200713220206862_842446399.png =440x)

添加修改返回值规则
![](_v_images/20200713220248144_636943322.png =540x)



修改后结果如下：（涨幅值因为每次刷新接口返回值不固定，所以导致修改无效）
![](_v_images/20200713220554012_2047916206.png =493x)




## 四、Restful API

REST全称是：REpresentational State Transfer，很多人是这样翻译的(表现层状态转移)。是一名作者叫： Roy Fielding在2000年发表论文的时候提出的，这位作者是HTTP协议的主要设计者，Apache服务器作者之一。


REST是一种设计规范，它具有六大特征：

- client-server模式：将客户端和服务器端的关注点分离. 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性.通过简化服务器模块也有助于服务器模块的可扩展性.
- 无状态：服务器不保存客户端的信息, 每一次从客户端发送的请求中, 要包含所有的必须的状态信息, 会话信息由客户端保存, 服务器端根据这些状态信息来处理请求
- 缓存：缓存约束要求对请求的响应中的数据被隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则授予客户端缓存以将响应数据重新用于以后的等效请求的权限
- 统一的接口：通过将通用的软件工程原理应用于组件接口，可以简化整个系统架构，并提高交互的可见性。为了获得统一的接口，需要多个体系结构约束来指导组件的行为。REST由四个接口约束定义：资源标识；通过表述操纵资源；自我描述的信息；并且，超媒体作为应用程序状态的引擎。
- 分层系统：分层系统样式允许通过限制组件的行为来使体系结构由层次结构层组成，从而使每个组件都无法“看到”与它们交互的直接层
- 按需代码：REST允许通过以applet或脚本的形式下载并执行代码来扩展客户端功能。通过减少预先实现的功能数量，简化了客户端。

REST中信息的关键抽象是一种资源。可以命名的任何信息都可以是资源：文档或图像，临时服务，其他资源的集合，非虚拟对象（例如人）等。REST使用资源标识符来标识组件之间交互中涉及的特定资源。

 - 直观简短的资源地址：URI，比如：http://example.com/resources。
 - 传输的资源：Web服务接受与返回的互联网媒体类型，比如：JSON，XML，YAML等。
 - 对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT或DELETE）

参考：https://restfulapi.net/

## 五、在浏览器输入URI发生了什么

主要讨论发起的是一个简单的HTTP请求

- URL解析
- DNS查询
- TCP连接
- 处理请求
- 接受响应
- 渲染页面

### 1、URL解析

- 地址解析
首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作

- HSTS
由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面

- 其它操作
浏览器还会进行一些额外的操作，比如安全检查、访问限制

- 检查缓存
![浏览器缓存检查](_v_images/20200721152126890_912275757.png =710x)


### 2、DNS查询

基本步骤
![](_v_images/20200721152239172_1732891966.png =703x)

目的是查找出服务器的IP地址

- 浏览器缓存
浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。

- 操作系统缓存
操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。

- 路由器缓存
路由器也有自己的缓存

- ISP DNS 缓存
ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存

- 根域名服务器查询
在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域
![](_v_images/20200721152741040_542051948.png =634x)

注意：

- 递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）
- 迭代方式，就是本地DNS服务器到根域名服务器查询的方式


### 3、TCP连接
TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：
![](_v_images/20200721153107945_641459462.png =725x)


- 应用层：发送HTTP请求
在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：

请求报头（Request Header）：请求方法、目标地址、遵循的协议等等
请求主体（其他参数）

- 传输层：TCP 传输报文
传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。在建立连接前，会先进行 TCP 三次握手

- 网络层：IP协议查询Mac地址
将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。
判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。

- 链路层：以太网协议
根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：

标头：数据包的发送者、接受者、数据类型
数据：数据包具体内容

  - mac地址：
  以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。
  - 广播
  发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。

### 4、服务器处理请求

![](_v_images/20200721153919864_641269894.png =720x)

- HTTPD
最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。它会监听得到的请求，然后开启一个子进程去处理这个请求。

- 处理请求
接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：
  - 验证是否配置虚拟主机
  - 验证虚拟主机是否接受此方法
  - 验证该用户可以使用该方法（根据 IP 地址、身份信息等）

- 重定向
假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。

- URL重写
然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。

否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上

### 5、浏览器接受响应
浏览器接收到来自服务器的响应资源后，会对资源进行分析。
首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。
如果响应资源进行了压缩（比如 gzip），还需要进行解压。
然后，对响应资源做缓存。
接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。

 
### 6、渲染页面

浏览器内核：
![浏览器内核](_v_images/20200721154429401_1750167812.png =682x)

不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。

![](_v_images/20200721154638497_986903325.png =776x)




参考地址：https://zhuanlan.zhihu.com/p/80551769