# 06-选择排序


选择排序（select sort）是一种简单直观的排序算法。它的工作原理如下。首先在末排序序列中找到最小（大）元素，存放到排序的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序的末尾。依此类推，直到所有元素均排序完毕。


选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则他不会被移动。选择排序每一次交换一对元素，他们当中至少有一个将被移动到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。


案例：

```
# 选择排序是每次将列表中的元素最大或最小放在最最左或最右的位置

a = [1, 4, 2, 100, 66, 5, 0]


# 第一次排序 [1, 4, 2, 100, 66, 5, 0] --->   [0, 4, 2, 100, 66, 5, 1]
# 第二次排序 [0, 4, 2, 100, 66, 5, 1] --->   [0, 1, 2, 100, 66, 5, 4]


def select_sort(arr: list):
    n = len(arr)
    for i in range(n - 1):
        min_index = i  # 定义最小元素位置，第一次默认是第一个元素位置， 每次剩余最小元素位置
        for j in range(i + 1, n):  # 从最小位置的下一个元素进行依此循环比较，寻找最小元素的索引位置
            if arr[min_index] > arr[j]:  # 判断当前最小位置的值和当前循环取到的值，进行对比
                min_index = j  # 改变最小元素的下标索引
        if min_index != i:  # 判断当前的最小值是否是自己，如果就是最小，则不需要交换
            arr[i], arr[min_index] = arr[min_index], arr[i]  # 循环完成一轮后，取到最小值的索引下标，然后进行对调


print("原列表：", a)
select_sort(a)
print("选择排序后列表：", a)

```

运行结果：

原列表： [1, 4, 2, 100, 66, 5, 0]
选择排序后列表： [0, 1, 2, 4, 5, 66, 100]



**时间复杂度：**

最优时间复杂度：O(n2)
最坏时间复杂度：O(n2)
稳定性： 不稳定（考虑升序每次选择最大的情况）  

 [1, 4, (166,1), 100, (166,2), 5, 0]    排序后结果--->[0, 1, 4, 5,100, (166,2), (166,1)] 这样就改变了相同元素（166，1）在（166，2）之前的位置。所以不稳定！